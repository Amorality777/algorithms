"""
https://contest.yandex.ru/contest/25597/run-report/108712606/
-- ПРИНЦИП РАБОТЫ --
Подготовка данных
1. Подсчет суммы чисел (+ поиск максимального числа) О(n)
2. Если сумма - нечетное число, то разбить на равные суммы не получится - завершение алгоритма
3. Нахождение половины суммы (далее exp_sum) - из набора чисел необходимо найти такую комбинацию,
чтобы она была равна половине общей суммы
4. Вычитание максимума из exp_sum, действие не обязательное, но т.к. каждое число должно быть задействовано,
то перед основным алгоритмом можно вычесть одно любое число и сократить кол-во дальнейших итераций.

Поиск ответа:
Для поиска ответа можно использовать алгоритм решения задачи "О рюкзаке" (динамическое решение).

 - Что будет храниться в массивах curr, prev?
В prev[i] будет храниться максимальный результат не превышающий i, если учитывать только ранее просмотренные числа.
В ячейке curr[i] будет храниться максимально возможная сумма чисел не превышающая i,
если учитывать только числа рассмотренные в prev + текущее число. Т.е. храним только последнее состояние.

 - Каким будет базовый случай для задачи?
 Для максимальной суммы равной нулю вне зависимости от набора доступных чисел возможная комбинация будет равна нулю.

 - Каким будет переход динамики?
 Необходимо взять максимум из двух чисел
 1. prev[i]/prev[cur_max_sum]
 2. Сумма текущего рассматриваемого числа num и результата из предыдущих вычислений prev[cur_max_sum - num]
 Второе число берется в расчет, только если оно не превосходит cur_max_sum.

 - Каким будет порядок вычисления данных в массиве dp?
 Построчное заполнение данных на каждое число в массиве

 - Где будет располагаться ответ на исходный вопрос?
 Если во время очередного шага curr[i] станет равен искомой сумме, то одинаковые суммы можно найти,
 если же после всех итераций максимальный ответ меньше искомой суммы, то одинаковые суммы найти нельзя.
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
О(n) - на поиск суммы
О(1\2*sum(seq)*n) - где sum(seq) число, равное сумме чисел заданного массива
=> О(n(1 + 1/2*sum(seq)) ~= О(n*sum(seq))
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(2*sum(seq) + 1) ~= O(sum(seq)), т.е. мы храним 2 массива временных данных равных половине суммы чисел заданного массива
"""
import sys


def find_sum(seq: tuple, exp_sum: int) -> bool:
    curr = [0] * (exp_sum + 1)

    for num in seq:
        if num > exp_sum or num == 0:
            continue
        prev = curr[:]
        for cur_max_sum in range(num, exp_sum + 1):
            new = num + prev[cur_max_sum - num]
            if new == exp_sum:
                return True
            elif new > cur_max_sum:
                curr[cur_max_sum] = prev[cur_max_sum]
            else:
                curr[cur_max_sum] = max(new, prev[cur_max_sum])

    return False


def main():
    input()
    score = tuple(map(int, sys.stdin.readline().rstrip().split()))

    sum_ = 0
    max_ = 0
    for s in score:
        sum_ += s
        max_ = max(max_, s)
    if sum_ % 2 != 0:
        ans = False
    elif (sum_ := sum_ // 2) == max_:
        ans = True
    else:
        ans = find_sum(score, sum_ - max_)
    print(ans)


main()
