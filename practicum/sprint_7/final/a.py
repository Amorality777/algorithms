"""
https://contest.yandex.ru/contest/25597/run-report/108950874/
-- ПРИНЦИП РАБОТЫ --
Решение с динамическим программированием:
- Что будет храниться в массивах curr, prev?
В curr[j] будет храниться минимальное кол-во преобразований для текущего состояния
В prev будут результаты вычислений для i - 1

- Каким будет базовый случай для задачи?
Если одна строка равна нулю, то для преобразования второй строки
понадобятся n операций удаления (либо вставки),
где n - длина второй строки.

- Каким будет переход динамики?
Необходимо вычислить 3 возможные операции и взять минимум:
 * удаление prev[j] + 1
 * вставка curr[j-1] + 1
 * замена prev[j - 1] + cost,
где cost цена замены текущих символов, если символы равно то cost=0, иначе 1.

- Каким будет порядок вычисления данных в массиве dp?
Для каждой новой буквы в s будем поэтапно добавлять новую букву из t.

- Где будет располагаться ответ на исходный вопрос?
 Последнее число в массиве curr

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Необходим двойной цикл длины обеих строк
О(n*m), где n длина строки s, m длина строки t
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
О(2*(m+1)) ~= О(m) - два массива с данными (предыдущие вычисления + текущие)
"""
from sys import stdin


def find_min_changes(s: str, t: str) -> int:
    curr = list(range(len(t) + 1))
    prev = list(range(len(t) + 1))
    for i in range(1, len(s) + 1):
        curr, prev = prev, curr
        curr[0] = i
        for j in range(1, len(t) + 1):
            cost = 0 if s[i - 1] == t[j - 1] else 1
            curr[j] = min(prev[j] + 1, curr[j - 1] + 1, prev[j - 1] + cost)
    return curr[-1]


def main():
    print(find_min_changes(stdin.readline().strip(), stdin.readline().strip()))


main()
