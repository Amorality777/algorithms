"""
https://contest.yandex.ru/contest/26133/run-report/110445946/
-- ПРИНЦИП РАБОТЫ --
1. Распаковка строки
Перебор всех символов строки,
если встретилась буква - добавить к конечной строке,
если цифра - вызвать рекурсию на обрезанную строку с текущего положения на +2 (с учетом скобки)
если остальное (закрывающая скобка) - то прекращение обхода (в текущей глубине)

При выходе из рекурсии возвращаются дополнительно:
- длина обработанной строки внутри рекурсии до первой закрывающей строки
- глубина рекурсии для подсчета всех закрывающих скобок

2. Поиск наибольшего префикса
Для поиска наибольшего префикса необходимо упорядочить массив строк и найти общий префикс у меньшей и большей строк,
т.к. разница данных строк будет максимально возможной.
Чтобы не хранить весь массив на каждой итерации распаковки сохраняю максимальное и минимальное значения.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Распаковка за О(L.p), где L.p сумма длин всех запакованных строк.
Поиск префикса в худшем случае за О(l.unp/2), где l.unp сумма длин всех распакованных строк (если их две и они равны).
Суммарная сложность == О(L.p + l.unp/2) ~= О(l.unp)
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Распаковка О(l.unp + 1/4l.p), где l.p длина запакованной строки
и 1/4 - это коэфф. рекурсии (2 скобки, число + минимум одна буква), l.unp - длина распакованной строки.

Хранение 2-строк для поиска префикса в худшем случае = О(l.unp)

В один момент времени пространственная сложность не будет превышать О(l.unp + 1/4l.p) ~= О(l.unp)
"""
import sys


def resolver(seq: str, depth=0) -> (str, int, int):
    resolve = []
    i = 0
    while i < len(seq):
        char = seq[i]
        if char.isalpha():
            resolve.append(char)
            i += 1
        elif char.isdigit():
            inner, offset, inn_depth = resolver(seq[i + 2:], depth + 1)
            i += (offset + (inn_depth - depth) * 3)
            resolve.append(int(char) * inner)
        else:
            break

    return ''.join(resolve), i, depth


def main() -> str:
    n = int(input())
    string = resolver(sys.stdin.readline().rstrip())[0]
    min_ = string
    max_ = string
    for _ in range(n - 1):
        string = resolver(sys.stdin.readline().rstrip())[0]
        min_ = min(min_, string)
        max_ = max(max_, string)
    prefix = []
    for i in range(len(min_)):
        if min_[i] != max_[i]:
            break
        prefix.append(min_[i])

    return ''.join(prefix)


print(main())
